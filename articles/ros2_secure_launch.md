---
layout: default
title: ROS 2 Secure Launch
permalink: articles/ros2_secure_launch.html
abstract:
  One of the key tenets of ROS 2 is reusability, helping end-users avoid constantly needing to reinvent the wheel. This article describes how that is applied in SROS 2, such that individual package maintainers can describe their package's communication requirements, and end-users can use those descriptions to secure their system without needing to be experts in every component being used.
author: '[Kyle Fazzari](https://github.com/kyrofa)'

published: true
categories: Security
---

{:toc}


# {{ page.title }}

<div class="abstract" markdown="1">
{{ page.abstract }}
</div>

Original Author: {{ page.author }}


## Background

DDS enforces access control using a signed permissions document for each domain participant (see the [DDS-Security spec][dds_security], section 9.4). In SROS 2, that permissions document is generated from a ROS-specific policy file that could include the permissions for one or many nodes.

There are a few ways to create that policy file. For example, one could craft it by hand. Another option is to launch the system of nodes for which a policy is desired, exercise it, and run `ros2 security generate_policy` to measure the ROS graph and generate a policy that covers its current state. These are both useful, however, there are issues with both of these methods: they put the onus of security squarely on the shoulders of end users.

To understand this point, a good parallel can be drawn between SROS 2 policies and AppArmor profiles. Consider a web developer putting together a web application. The developer would like to confine the application with AppArmor. However, they quickly learn that not only do they need to confine the little piece they've written in e.g. Python and in which they are an expert, they need to confine the rest of the stack as well: web server, database, etc. Well, they aren't experts in those systems. They don't know what it truly requires, and as time is a premium they don't have time to learn. This typically works out in one of two ways:

1. The developer throwing up their hands and skipping confinement altogether
2. The developer moving ahead with confinement and doing a poor job of it

Thankfully, this is not the status quo in AppArmor. Upstream maintainers understand that they are in a much better position than end users to properly confine the components for which they are responsible. As a result, components of the web stack (e.g. Apache, MySQL, etc.) often ship their own AppArmor profiles or abstractions that can be easily integrated by end users.

SROS 2 is following a similar path, defining a way for upstream packages to specify the communication requirements of the nodes in the package, such that a final policy can be easily generated by the end user.


## Package interface definition

So how do upstream packages specify their communication requirements? They define their interface, which is a high-level description of all the parameters, topics, services, and actions provided or required by each node within the package. This provides all the information necessary to generate a policy (and thus DDS permissions), while also providing the metadata necessary for future developments, such as interface-based design using graphical tools, or static analysis of launch files (e.g. "You're remapping from a topic that isn't being published!").

The package interface is exported from the `package.xml`, and might look something like this:

```xml
<package format="2">
  <name>example-package</name>

  <!-- snip -->

  <export>
    <interface>
      <node name="example_node">
        <parameter name="example_parameter" type="bool" \>
        <topic name="/foo/bar" type="std_msgs/String" publish="true" \>
        <service name="/example_service" type="std_srvs/srv/Empty" client="true" \>
        <action name="/example_action", type="example_interfaces/action/Fibonacci" server="true" \>
      </node>
    </interface>
  </export>
```


## Securing the system with minimal effort

The ideal scenario is to make creating both the keys and the policy as easy as possible on the end user. In fact, it's possible to abstract the fact that keys and an overall policy are required at all. A few different pieces of information are necessary in order to meet this goal:

1. Knowledge of all nodes (and their packages) involved in the system
2. Knowledge of which parameter/topic/service/action each node requires, and the type of access required

Let's begin with (2). The exported package interface we just discussed provides most of this information but there's an important function for which we haven't accounted: remapping. Remapping happens at a higher level than where the DDS permissions are applied. In other words, the policy needs to reflect the expected communications of the system _post-remap_, or any remapping will be met by a denial.

As it happens, the solution is the same as the solution for (1): a launch file. A launch file nicely describes the entire system: all nodes required (and their packages), as well as any remapping that need to be applied.

In fact, assuming that all nodes in the launch file have an accurate interface exported for it, `ros2 launch` itself can lock the entire launched system down with a flag:

    $ ros2 launch --secure <package> <launch file>

This simply generates an ephemeral keystore and keys for each node in the launched system, as well as generates a policy and final permissions for each node, sets the proper environment to enable and enforce DDS-Security, and finally launches the system.

[dds_security]: https://www.omg.org/spec/DDS-SECURITY/1.1/PDF
